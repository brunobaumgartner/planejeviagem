/**
 * TRAVELPAYOUTS DESTINATIONS - Busca destinos din√¢micos da API
 * Sistema de cache inteligente para otimiza√ß√£o de performance
 */

import * as kv from './kv_store.tsx';

const TRAVELPAYOUTS_TOKEN = Deno.env.get('TRAVELPAYOUTS_TOKEN');
const TRAVELPAYOUTS_MARKER = Deno.env.get('TRAVELPAYOUTS_MARKER');

// Cache key prefixes
const CACHE_PREFIX = 'tp_destinations';
const CACHE_PREFIX_CITIES = 'tp_city_data';
const CACHE_DURATION_HOURS = 24; // Cache por 24 horas

interface DestinationData {
  code: string;
  name: string;
  country: string;
  countryCode: string;
  popularity: number;
  averagePrice: number | null;
  lastUpdated: string;
}

interface CachedDestinations {
  destinations: DestinationData[];
  origin: string;
  cachedAt: string;
  expiresAt: string;
}

/**
 * Busca destinos populares da API Travelpayouts
 */
export async function fetchPopularDestinations(origin: string = 'SAO'): Promise<DestinationData[]> {
  console.log(`[TPDestinations] üîç Buscando destinos populares de ${origin}`);

  try {
    // Verificar cache primeiro
    const cached = await getCachedDestinations(origin);
    if (cached) {
      console.log(`[TPDestinations] ‚úÖ Cache hit - ${cached.destinations.length} destinos`);
      return cached.destinations;
    }

    console.log(`[TPDestinations] üì° Cache miss - buscando da API`);

    // Buscar da API Travelpayouts - Popular directions
    const url = `https://api.travelpayouts.com/v1/city-directions?origin=${origin}&currency=brl&token=${TRAVELPAYOUTS_TOKEN}`;
    
    const response = await fetch(url);
    
    if (!response.ok) {
      throw new Error(`Travelpayouts API error: ${response.status}`);
    }

    const data = await response.json();
    
    if (!data.success || !data.data) {
      console.warn('[TPDestinations] ‚ö†Ô∏è API retornou sem dados');
      return [];
    }

    // Processar dados e mapear para nossa estrutura
    const destinations: DestinationData[] = Object.entries(data.data)
      .map(([code, info]: [string, any]) => {
        // Buscar informa√ß√µes da cidade
        const cityInfo = info;
        
        return {
          code: code,
          name: cityInfo.name || code,
          country: cityInfo.country_name || 'Desconhecido',
          countryCode: cityInfo.country_code || '',
          popularity: cityInfo.popularity || 0,
          averagePrice: cityInfo.price || null,
          lastUpdated: new Date().toISOString()
        };
      })
      .filter(dest => dest.averagePrice !== null) // Filtrar destinos sem pre√ßo
      .sort((a, b) => b.popularity - a.popularity) // Ordenar por popularidade
      .slice(0, 50); // Top 50 destinos

    console.log(`[TPDestinations] ‚úÖ ${destinations.length} destinos encontrados`);

    // Enriquecer destinos com dados completos de cidades
    const enrichedDestinations = await enrichDestinationsWithCityData(destinations);

    // Salvar no cache
    await cacheDestinations(origin, enrichedDestinations);

    return enrichedDestinations;

  } catch (error) {
    console.error('[TPDestinations] ‚ùå Erro ao buscar destinos:', error);
    
    // Tentar retornar cache expirado como fallback
    const expiredCache = await getExpiredCache(origin);
    if (expiredCache) {
      console.warn('[TPDestinations] ‚ö†Ô∏è Usando cache expirado como fallback');
      return expiredCache.destinations;
    }
    
    return [];
  }
}

/**
 * Busca destinos do cache se ainda v√°lido
 */
async function getCachedDestinations(origin: string): Promise<CachedDestinations | null> {
  try {
    const cacheKey = `${CACHE_PREFIX}:${origin}`;
    const cached = await kv.get(cacheKey);
    
    if (!cached) return null;
    
    const data = cached as CachedDestinations;
    const now = new Date();
    const expiresAt = new Date(data.expiresAt);
    
    if (now > expiresAt) {
      console.log('[TPDestinations] Cache expirado');
      return null;
    }
    
    return data;
  } catch (error) {
    console.error('[TPDestinations] Erro ao buscar cache:', error);
    return null;
  }
}

/**
 * Busca cache expirado (fallback)
 */
async function getExpiredCache(origin: string): Promise<CachedDestinations | null> {
  try {
    const cacheKey = `${CACHE_PREFIX}:${origin}`;
    const cached = await kv.get(cacheKey);
    return cached as CachedDestinations | null;
  } catch (error) {
    return null;
  }
}

/**
 * Salva destinos no cache
 */
async function cacheDestinations(origin: string, destinations: DestinationData[]): Promise<void> {
  try {
    const now = new Date();
    const expiresAt = new Date(now.getTime() + CACHE_DURATION_HOURS * 60 * 60 * 1000);
    
    const cacheData: CachedDestinations = {
      destinations,
      origin,
      cachedAt: now.toISOString(),
      expiresAt: expiresAt.toISOString()
    };
    
    const cacheKey = `${CACHE_PREFIX}:${origin}`;
    await kv.set(cacheKey, cacheData);
    
    console.log(`[TPDestinations] üíæ Cache salvo (expira em ${CACHE_DURATION_HOURS}h)`);
  } catch (error) {
    console.error('[TPDestinations] Erro ao salvar cache:', error);
  }
}

/**
 * For√ßa atualiza√ß√£o do cache
 */
export async function refreshDestinationsCache(origin: string = 'SAO'): Promise<void> {
  console.log(`[TPDestinations] üîÑ For√ßando atualiza√ß√£o do cache para ${origin}`);
  
  // Deletar cache existente
  const cacheKey = `${CACHE_PREFIX}:${origin}`;
  await kv.del(cacheKey);
  
  // Buscar novamente (vai popular o cache)
  await fetchPopularDestinations(origin);
}

/**
 * Busca informa√ß√µes de uma cidade espec√≠fica
 */
export async function getCityInfo(code: string): Promise<any> {
  try {
    const cities = await fetchAllCitiesData();
    return cities.find((c: any) => c.code === code.toUpperCase()) || null;
  } catch {
    return null;
  }
}

/**
 * Busca dados completos de m√∫ltiplas cidades de uma vez
 * Usa a Data API da Travelpayouts para obter nomes reais
 */
export async function enrichDestinationsWithCityData(destinations: DestinationData[]): Promise<DestinationData[]> {
  console.log(`[TPDestinations] üîç Enriquecendo dados de ${destinations.length} cidades...`);
  
  try {
    // Baixar arquivo completo de cidades (cachear localmente)
    const citiesData = await fetchAllCitiesData();
    
    if (!citiesData || citiesData.length === 0) {
      console.warn('[TPDestinations] ‚ö†Ô∏è N√£o conseguiu buscar dados de cidades');
      return destinations;
    }
    
    // Criar mapa c√≥digo -> dados
    const cityMap = new Map(citiesData.map((city: any) => [city.code, city]));
    
    // Enriquecer destinos com dados reais
    const enriched = destinations.map(dest => {
      const cityData = cityMap.get(dest.code);
      
      if (cityData) {
        return {
          ...dest,
          name: cityData.name || dest.name,
          country: cityData.country_name || dest.country,
          countryCode: cityData.country_code || dest.countryCode,
        };
      }
      
      return dest;
    });
    
    console.log(`[TPDestinations] ‚úÖ Dados enriquecidos com sucesso`);
    return enriched;
    
  } catch (error) {
    console.error('[TPDestinations] ‚ùå Erro ao enriquecer dados:', error);
    return destinations;
  }
}

/**
 * Busca arquivo completo de cidades da Travelpayouts
 * Cacheia por 7 dias pois raramente muda
 */
async function fetchAllCitiesData(): Promise<any[]> {
  const cacheKey = `${CACHE_PREFIX_CITIES}:all`;
  
  try {
    // Verificar cache primeiro
    const cached = await kv.get(cacheKey);
    if (cached) {
      const data = cached as { cities: any[], cachedAt: string, expiresAt: string };
      const now = new Date();
      const expiresAt = new Date(data.expiresAt);
      
      if (now < expiresAt) {
        console.log('[TPDestinations] ‚úÖ Cache de cidades encontrado');
        return data.cities;
      }
    }
    
    console.log('[TPDestinations] üì° Baixando arquivo de cidades da API...');
    
    // Baixar arquivo completo de cidades
    const url = `https://api.travelpayouts.com/data/pt/cities.json`;
    const response = await fetch(url);
    
    if (!response.ok) {
      throw new Error(`Erro ao buscar cidades: ${response.status}`);
    }
    
    const cities = await response.json();
    
    // Cachear por 7 dias
    const now = new Date();
    const expiresAt = new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000);
    
    await kv.set(cacheKey, {
      cities,
      cachedAt: now.toISOString(),
      expiresAt: expiresAt.toISOString()
    });
    
    console.log(`[TPDestinations] ‚úÖ ${cities.length} cidades cacheadas por 7 dias`);
    
    return cities;
    
  } catch (error) {
    console.error('[TPDestinations] ‚ùå Erro ao buscar cidades:', error);
    return [];
  }
}

/**
 * Busca c√≥digo IATA pelo nome da cidade
 */
export async function findCityCode(cityName: string, origin: string = 'SAO'): Promise<string | null> {
  const destinations = await fetchPopularDestinations(origin);
  const normalized = cityName.toLowerCase().trim();
  
  const found = destinations.find(dest => 
    dest.name.toLowerCase() === normalized ||
    dest.name.toLowerCase().includes(normalized)
  );
  
  return found ? found.code : null;
}

/**
 * Estima custos de acomoda√ß√£o e gastos di√°rios baseado no pa√≠s/regi√£o
 */
export function estimateDestinationCosts(destination: DestinationData): {
  accommodation: number;
  dailyExpenses: number;
  emoji: string;
} {
  const countryCode = destination.countryCode;
  
  // Pa√≠ses muito caros
  const veryExpensive = ['US', 'GB', 'CH', 'NO', 'SE', 'DK', 'IS', 'JP', 'AU', 'SG', 'AE'];
  // Pa√≠ses caros
  const expensive = ['FR', 'DE', 'IT', 'ES', 'NL', 'BE', 'AT', 'IE', 'FI', 'CA', 'KR'];
  // Pa√≠ses m√©dios
  const medium = ['CL', 'AR', 'UY', 'MX', 'CR', 'PT', 'GR', 'CZ', 'PL', 'HU'];
  // Pa√≠ses baratos (Brasil e similares)
  const cheap = ['BR', 'CO', 'PE', 'EC', 'BO', 'PY', 'TH', 'VN', 'ID', 'PH'];

  let accommodation = 250;
  let dailyExpenses = 150;
  let emoji = '‚úàÔ∏è';

  if (veryExpensive.includes(countryCode)) {
    accommodation = 500;
    dailyExpenses = 300;
  } else if (expensive.includes(countryCode)) {
    accommodation = 350;
    dailyExpenses = 220;
  } else if (medium.includes(countryCode)) {
    accommodation = 280;
    dailyExpenses = 180;
  } else if (cheap.includes(countryCode)) {
    accommodation = 200;
    dailyExpenses = 120;
  }

  // Emojis por pa√≠s
  const emojiMap: Record<string, string> = {
    'BR': 'üáßüá∑',
    'AR': 'üíÉ',
    'CL': 'üèîÔ∏è',
    'UY': 'üá∫üáæ',
    'US': 'üóΩ',
    'MX': 'üåÆ',
    'FR': 'üóº',
    'ES': 'üá™üá∏',
    'PT': 'üáµüáπ',
    'IT': 'üèõÔ∏è',
    'GB': 'üá¨üáß',
    'JP': 'üóæ',
  };

  emoji = emojiMap[countryCode] || '‚úàÔ∏è';

  return { accommodation, dailyExpenses, emoji };
}

/**
 * Resolve um c√≥digo IATA (CITY ou AIRPORT) para nome leg√≠vel
 * Usado principalmente no frontend
 */
export async function resolveIataToName(code: string): Promise<string> {
  const normalized = code.toUpperCase();

  try {
    const cities = await fetchAllCitiesData();

    const city = cities.find(
      (c: any) => c.code === normalized
    );

    if (!city) {
      return normalized;
    }

    return city.name || normalized;

  } catch (error) {
    console.error(`[TPDestinations] Erro ao resolver IATA ${code}`, error);
    return normalized;
  }
}
